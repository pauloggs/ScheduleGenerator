# ScheduleGenerator
An API to GET the recipe information from RecipeApi and generate lighting and watering schedules.

# How to run
**Docker container to Docker container**

1. Make sure that the RecipeApi is running in a docker container
2. Find the name of the network that the RecipeApi container created at runtime by running the following in a cmd prompt:
> `docker network ls`
3. This might for example return `tech-test-software-engineer_default`
4. Alter the docker-compose.json file's networks / default / name value to this, for example `name: tech-test-software-engineer_default`
5. Find the IP address of the RecipeApi container on this network by running the following in a cmd prompt (tech-test-software-engineer-recipeapi-1 being the name of the RecipeApi container, found by running `docker container ls` in a cmd prompt):
> `docker inspect -f "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}" tech-test-software-engineer-recipeapi-1`
6. Alter the Dockerfile's `ENV BaseUrl` to this, for example `"http://172.18.0.2/"`
7. Run the following in a cmd prompt:
> `docker-compose.up`
8. Access it by `localhost:9000/swagger`
9. The swagger page for ScenarioGenerator should appear

**Kestral/IIS Express ScenarioGenerator to RecipeApi Docker container**

1. Make sure that the RecipeApi is running in a docker container
2. Open the ScenarioGenerator solution in visual studio
3. Start without debugging
4. The swagger page for ScenarioGenerator should appear


# Dev Approach
The first steps were to create an API that could connect to the RecipeApi. Initially the ScenariosGenerator would just return back the list of Recipes.

The second step was to ensure that this new API would run in a Docker container and be able to connect to the RecipeApi container. This is achieved by a section of the docker-compose file that connects to the network that is created when the RecipeApi container is run.

Generally the approach has been the following sequence
1. Decide on the modelling
2. Break up the processing into different services (Http, Converter, Processing)
3. Implement each service with unit tests

# Modelling
The main decision here was how to model the output of commands that would be the end product of all the processing.

It seemed sensible to separate the list of watering commands from the lighting commands, since from a domain-driven design point of view they probably represent physical actions taken by completely different sets of machinery.

**Output**

_TowerCommands_
* List > _LightingCommand_
* List > _WateringCommand_ 

_LightingCommand_ and _WateringCommand_ both inherit from the abstract class _Command_, which holds the execution datetime, tray number and recipe.
Strictly speaking the _Command_ object doesn't really need the recipe property, but it's included in the interests of ensuring that the right command is being applied to the right recipe.

**Input**

There are two parts to the input model, first there's the actual request that is posted containing the list of (tray number / start datetime / recipe) combinations. This object that represents this is called _RecipeTrayStarts_. And secondly there is a _Recipe_ object, a List of which represents the recipe data that is returned back from the _RecipeApi_.


# Processing
The commands for the tower were generated by the following algorithm
* Loop through each (tray number / recipe / start datetime) combination in the posted request
* lookup the Recipe, throw an exception if not found

* to generate the _WateringCommand_ list
* > order the _WateringPhase_ list by the order property
* > for each _WateringPhase_
* > > for each _Repetition_
* > > > set the _currentDateTime_ by adding the hours and minutes
* > > > create a _WateringCommand_ with this time, with the _Amount_ of water specified by the _Recipe_
* to generate the _LightingCommand_ list, there's an additional step that handles operations:
* > order the _LightingPhase_ list by the order property
* > for each _LightingPhase_
* > > for each Repetition
* > > > set the _currentDateTime_ by adding the hours and minutes
* > > > for each _Operation_
* > > > > set the _executionTime_ by adding the _offsetHours_ and _offsetMinutes_
* > > > > create a _LightingCommand_ with this time, with the _LightIntensity_ specified by the _Recipe_

**Shortcuts**

Unit test coverage of the ProcessorService is pretty sketchy.
Definitely need some DateTime-based tests included here to check the the generated commands have the correct execution dates.
Currently there are only checks on the number of commands created.


# Issues
Had some issues getting FluentValidations to work with dotnet 6 using the recommended methods to configure services (AddFluentValidation() etc. see: 
https://docs.fluentvalidation.net/en/latest/aspnet.html). See the following ticket: https://github.com/FluentValidation/FluentValidation/issues/1652
